{
    "collab_server" : "",
    "contents" : "#'@title Combine EEMs produce by the Cary Eclipse fluorometer into a cube\n#'ready for PARAFAC analysis in Matlab\n#'\n#'@description  This function reads any number of EEMs and produce a cube of EEMs.\n#'It enables the standardization into Raman Unit and instrument's corrections.\n#'\n#'@path Full path of the working directory (can be called using getwd())\n#'@param excitation is a vector of three variables of the scanning setup (min,max,interval).\n#'Default is c(220,450,5)\n#'@param emission is a vector of three variables of the scanning setup (min,max,interval).\n#'Default is c(230,600,2)\n#'@param  EMCOL  is a logical parameter indicating whether or not the emission are\n#'stored as column in the csv file. Default is FALSE.\n#'@param \n#'@param samplepercsv is a parameter which indicates the number of sample in the csv file coming from the fluorometer.\n#'@param RU is a logical parameter to transform fluorescence intensities into Raman Unit at Ex = 350 nm.\n#'Default is TRUE.\n#'@param EmEx.cor is a logical parameter to correct EEMs for emission and excitation corrections.\n#'Default is True. Emission and excitation file must be numerics only stored in csv file.\n#'\n#'\n#'@export\n#'\n#'\n\n\n\nPARAFAC.cube.design = function(path = getwd(), excitation = c(220,450,5), emission = c(230, 600, 2), EMCOL = F, Subtract.Blank = T, RU = T, rm.corner=T, EmEx.cor = T, Inner=T, pathlength = 1, split=\"_\")\n{\n  samplepercsv = 4\n  wlex <- seq(excitation[1], excitation[2], excitation[3])\n  wlem <- seq(emission[1], emission[2], emission[3])\n  nex <- length(wlex)\n  nem  <- length(wlem)\n\n\tsetwd(\".\\\\data\")\n\t\n\tfile.dir = list.files()\n\tnano.temp = grep(\"nano\", file.dir)\n\tcdom.temp = grep(\"CDOM\",file.dir)\n\tfile.dir = file.dir[-nano.temp]\n\tfile.dir = file.dir[-cdom.temp]\n\tfile.list = list()\n\t  \n\tfor(i in 1:length(file.dir))\n\t{\n\t  file.list[[i]] = paste(file.dir[i],\"/\",list.files(file.dir[i]),sep=\"\")\n\t}\n  file.list = unlist(file.list)\n  csv.count <- str_count(file.list,\"_\") + 1\n\t  \n  file.sample = file.list[csv.count==1]\n  file.sample2 = file.list[csv.count==2]\n  file.sample3 = file.list[csv.count==3]\n  file.sample4 = file.list[csv.count==4]\n  \n  \n\t#Reading the sample files and creating a list of EEMs\n\tcounter = 1\n\tdata.list <- list()\n\tfilename <- list()\n\tindex = 0\n\tlist.length = 0\n\twhile(counter <= samplepercsv)\n\t{\n\t\tif(counter == 1)\n\t\t{\n\t\t\tfile.data <- file.sample\n\t\t}\n\t\t\n\t\tif(counter == 2)\n\t\t{\n\t\t\tfile.data <- file.sample2\n\t\t}\n\t\t\n\t\tif(counter == 3)\n\t\t{\n\t\t\tfile.data <- file.sample3\n\t\t}\n\t\t\n\t\tif(counter == 4)\n\t\t{\n\t\t\tfile.data <- file.sample4\n\t\t}\n\t\t\t\t\n\t\tif(length(file.data) > 1)\n\t\t{\n\t\t\tfor (i in 1:length(file.data))\n\t\t\t{\n\t\t\t\t\tEEM = read.EEM.Richard(file.data[i],excitation,emission, EMCOL, counter, split=split)\n\t\t\t\t\tdata.list[[i + index]] <- EEM$EEM.list\n\t\t\t\t\tfilename[[i + index]] <- unlist(EEM$EEM.name)\n\t\t\t}\n\t\t\tindex = index + length(file.data)\n\t\t\tlist.length = list.length + length(file.data) * counter\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(length(file.data)==1)\n\t\t\t{\n\t\t\t\tEEM = read.EEM.Richard(file.data,excitation,emission, EMCOL, counter, split=split)\n\t\t\t\tdata.list[[index + 1]] = EEM$EEM.list\n\t\t\t\tfilename[[index + 1]] = unlist(EEM$EEM.name)\n\t\t\t\tindex = index + 1\n\t\t\t\tlist.length = list.length + counter\n\t\t\t}\n\t\t}\n\t\tcounter = counter + 1\n\t}\n\tcube <- array(unlist(data.list),dim=c(nex,nem,list.length))\n\tif(Subtract.Blank)\n\t{\n\t  Raman = NanoMean(path, excitation, emission, EMCOL,RU=T, split=split)\n\t  for(k in 1:length(cube[1,1,]))\n\t  {\n\t    cube[,,k] <- cube[,,k]- Raman[[1]]$eem[,,1]\n\t  }\n\t}\n\tif(Inner)\n\t{\n\t  cube = InnerFilter(path, cube, excitation, emission, pathlength,filename)\n\t}\n\n\tif(rm.corner)\n\tfor(k in 1:length(cube[1,1,]))\n\t{\n\t  for(i in 1:length(cube[,1,1]))\n\t  {\n\t    cube[i,wlem<=(wlex[i]-10),k]=0 #Put all data below 1st order Rayleigh equal 0\n\t  }\n\t}\n\t\n  if(RU)\n  {\n    if(Subtract.Blank == F)\n    {\n        Raman = NanoMean(path, excitation, emission, EMCOL, split=split,RU=T)\n    }\n    \n    RAMANInt = plot.integrate.RAMAN(Raman, maxF, graph=F)\n    cube.RU=cube\n    for(k in 1:length(cube[1,1,]))\n    {\n      cube.RU[,,k] <- cube[,,k]/RAMANInt\n    }\n    \n    if(EmEx.cor)\n    {\n      file.Em = read.csv(\"../Emcorr_220 to 600.csv\")\n      file.Ex = read.csv(\"../Excorr.csv\")\n      Ex.cor = as.numeric(na.omit(file.Ex[match(round(file.Ex[,1]),wlex),2]))\n      Em.cor = t(as.numeric(na.omit(file.Em[match(round(file.Em[,1]),wlem),2])))\n      Cor.mat = Ex.cor %*% Em.cor\n      cube.RU.EmEx = cube.RU\n      for(k in 1:length(cube.RU[1,1,]))\n      {\n        cube.RU.EmEx[,,k] = cube.RU[,,k] * Cor.mat\n      setwd(\"..\")\n      return(list(cube.RU.EmEx,filename,wlex,wlem,list.length))\n      }\n    setwd(\"..\")  \n    return(list(cube.RU,filename,wlex,wlem,list.length))\n    }\n    if(EmEx.cor)\n    {\n      file.Em = read.csv(\"../Emcorr_220 to 600.csv\")\n      file.Ex = read.csv(\"../Excorr.csv\")\n      Ex.cor = as.numeric(na.omit(file.Ex[match(round(file.Ex[,1]),wlex),2]))\n      Em.cor = t(as.numeric(na.omit(file.Em[match(round(file.Em[,1]),wlem),2])))\n      Cor.mat = Ex.cor %*% Em.cor\n      cube.EmEx = cube\n      for(k in 1:length(cube[1,1,]))\n      {\n        cube.EmEx[,,k] = cube[,,k] * Cor.mat\n      }\n    setwd(\"..\")\n    return(list(cube.EmEx,filename,wlex,wlem,list.length))\n    }\n  setwd(\"..\")\n\treturn(list(cube,filename,wlex,wlem,list.length))\n  }\n}\n\n",
    "created" : 1493252432300.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2802232907",
    "id" : "EF394B96",
    "lastKnownWriteTime" : 1493254155,
    "last_content_update" : 1493254155363,
    "path" : "H:/UniversitÃ©/Github/CorrectionPARAFACinR/Functions/PARAFAC.cube.design.R",
    "project_path" : "Functions/PARAFAC.cube.design.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}